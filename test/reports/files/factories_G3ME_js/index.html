<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title></title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome-ie7.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/jsoverson/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>factories/G3ME.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"></i></a></h2>
      <p class="stat">56.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h2>
      <p class="stat">557</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty"></i></a></h2>
      <p class="stat">92.18</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs"></i></a></h2>
      <p class="stat">8.54</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">angular.module(&#039;smartgeomobile&#039;).factory(&#039;G3ME&#039;, function (SQLite, Smartgeo, $rootScope, i18n) {

    &#039;use strict&#039;;

    var G3ME = {

        _MAX_ZOOM: 22,
        _MIN_ZOOM: 0,

        active_layers: false,
        assetsMarkers: [],

        mapDiv: null,
        mapDivId: null,
        databases: {},

        benchMe: false,
        benchmarks: {},
        benchmarkResults: [],
        benchmarkGlobalResultPerSQL: 0,
        benchmarkGlobalResultPerTile: 0,
        benchmarkElapsedBenchmarks: 0,
        benchmarksLimit: 10,
        benchmarkGeneralStatistics: [],

        filecacheIsEnable: false,

        initialize: function (mapDivId, site, target, marker, zoom) {

            this.site = site;
            this.tileUrl = this.site.EXTERNAL_TILEURL;
            this.mapDiv = document.getElementById(mapDivId);
            this.map = new L.map(this.mapDiv, {
                attributionControl: false,
                zoomControl: false,
                maxZoom: G3ME._MAX_ZOOM,
                minZoom: G3ME._MIN_ZOOM
            }).addControl(L.control.zoom({
                position: &#039;topright&#039;
            }));

            L.control.scale({
                &#039;imperial&#039;: false
            }).addTo(this.map);

            if (!target || !target.length || G3ME.benchMe) {
                target = [
                    [this.site.extent.ymin, this.site.extent.xmin],
                    [this.site.extent.ymax, this.site.extent.xmax]
                ];
            }

            if (target[0] instanceof Array || G3ME.benchMe) {
                // target is an extend
                G3ME.map.fitBounds(target);
            } else if (target[0] === 1 * target[0] &amp;&amp; (target instanceof Object)) {
                // target is a point
                G3ME.map.setView(target, zoom || 18);
                if (marker) {
                    if (marker._map) {
                        (marker._map.removeLayer)(marker);
                    }
                    marker.addTo(G3ME.map);
                }
            } else if (Smartgeo.get(&#039;lastLeafletMapExtent&#039;)) {
                G3ME.map.fitBounds(Smartgeo.get(&#039;lastLeafletMapExtent&#039;));
            } else {
                G3ME.map.fitBounds(target);
            }

            G3ME.invalidateMapSize();

            if (!this.tileUrl) {
                this.tileUrl = Smartgeo.get(&#039;url&#039;).replace(/index.php.+$/, &#039;&#039;);
                this.tileUrl += &#039;getTuileTMS.php?z={z}&amp;x={x}&amp;y={y}&#039;;
            }
            // this.tileUrl=&#039;http://{s}.tile.cloudmade.com/BC9A493B41014CAABB98F0471D759707/997/256/{z}/{x}/{y}.png&#039;;
            // this.tileUrl=&#039;http://{s}.tile.cloudmade.com/4f5c5233516d4c39a218425764d98def/999/256/{z}/{x}/{y}.png&#039;;
            var BackgroundTile;

            if (this.filecacheIsEnable) {
                BackgroundTile = L.TileLayer.FileCache;
            } else {
                BackgroundTile = L.TileLayer;
            }
            this.BackgroundTile = new BackgroundTile(this.tileUrl, {
                maxZoom: G3ME._MAX_ZOOM,
                minZoom: G3ME._MIN_ZOOM
            }).addTo(this.map);

            this.canvasTile = new L.TileLayer.Canvas({
                maxZoom: G3ME._MAX_ZOOM,
                minZoom: G3ME._MIN_ZOOM
            }).addTo(this.map);

            this.canvasTile.drawTile = function (canvas, tilePoint) {
                G3ME.drawTile(canvas, tilePoint, G3ME.benchMe);
            };

            for (var symbol in this.site.symbology) {
                if (!this.site.symbology[symbol] || !this.site.symbology[symbol].style) {
                    continue;
                }
                var image = new Image();
                image.src = this.site.symbology[symbol].style.symbol.icon;
                this.site.symbology[symbol].style.image = image;
            }
            this.canvasTile.redraw();

            window.test = this.BackgroundTile;

            $(window).on(&#039;resize&#039;, function () {
                G3ME.tilesOnScreen = ~~ ((window.innerHeight / 256) * (window.innerWidth / 256)) + 1;
            });

            G3ME.tilesOnScreen = ~~ ((window.innerHeight / 256) * (window.innerWidth / 256)) + 1;

        },

        getLineStringMiddle: function (lineString) {
            var lineStringLength = 0;
            var coords = lineString.coordinates;
            for (var i = 0; i &lt; coords.length - 1; i++) {
                var p1 = coords[i];
                var p2 = coords[i + 1];
                p1[2] = lineStringLength;
                lineStringLength += Math.sqrt(Math.pow(p2[0] - p1[0], 2) + Math.pow(p2[1] - p1[1], 2));
            }
            coords[coords.length - 1][2] = lineStringLength;
            var lineStringMiddle = lineStringLength / 2;
            for (i = 0; i &lt; coords.length - 1; i++) {
                var p1b = coords[i];
                var p2b = coords[i + 1];
                if (p1b[2] &lt;= lineStringMiddle &amp;&amp; lineStringMiddle &lt;= p2b[2]) {
                    var raptor = (lineStringMiddle - p1b[2]) / (p2b[2] - p1b[2]);
                    return [p1b[1] + raptor * (p2b[1] - p1b[1]), p1b[0] + raptor * (p2b[0] - p1b[0]), p1b];
                }
            }
        },

        parseTarget: function (site, target, callback, error) {
            if (G3ME.isLatLngString(target)) {
                // it&#039;s a position ! returning [lat, lng]
                callback(target.split(&#039;,&#039;));
            } else {
                // so maybe it&#039;s an asset id ?
                Smartgeo.findAssetsByGuids(site, target, function (assets) {
                    if (!assets.length) {
                        callback([]);
                    } else {
                        var geometry;
                        try {
                            geometry = JSON.parse(assets[0].geometry);
                        } catch (e) {
                            geometry = assets[0].geometry;
                        }
                        if (geometry.type === &#039;Point&#039;) {
                            callback([assets[0].ymin, assets[0].xmin]);
                        } else {
                            callback(G3ME.getLineStringMiddle(geometry));
                        }
                    }
                }, null, null, function () {
                    (error || function () {})();
                });
            }
        },

        isLatLngString: function (str) {
            return ((str ||  &quot;&quot;).match(/^-?\d+[.]\d*,-?\d+[.]\d*$/) !== null);
        },

        invalidateMapSize: function (timeout, callback) {
            timeout = timeout || 10;
            setTimeout(function () {
                G3ME.map.invalidateSize();
                (callback || function () {})();
            }, 10);
        },

        getExtentsFromAssetsList: function (assets) {
            var xmin = Infinity,
                xmax = -Infinity,
                ymin = Infinity,
                ymax = -Infinity;
            for (var i = 0; i &lt; assets.length; i++) {
                xmin = assets[i].xmin &lt; xmin ? assets[i].xmin : xmin;
                ymin = assets[i].ymin &lt; ymin ? assets[i].ymin : ymin;
                xmax = assets[i].xmax &gt; xmax ? assets[i].xmax : xmax;
                ymax = assets[i].ymax &gt; ymax ? assets[i].ymax : ymax;
            }
            return {
                xmin: xmin,
                xmax: xmax,
                ymin: ymin,
                ymax: ymax
            };
        },

        extents_match: function (extent1, extent2) {
            return !(extent1.xmax &lt; extent2.xmin ||
                extent1.xmin &gt; extent2.xmax ||
                extent1.ymin &gt; extent2.ymax ||
                extent1.ymax &lt; extent2.ymin);
        },

        fullscreen: function () {
            G3ME.mapDiv.style.width = &quot;100%&quot;;
            G3ME.invalidateMapSize();
        },

        reduceMapWidth: function (px) {
            G3ME.mapDiv.style.width = (window.innerWidth - px) + &#039;px&#039;;
            G3ME.invalidateMapSize();
        },

        setVisibility: function (layers) {
            this.active_layers = [];
            for (var i in layers) {
                if (layers[i].status) {
                    this.active_layers.push(i);
                }
            }
            this.canvasTile.redraw();
        },
        getVisibility: function () {
            if (this.active_layers === false) {
                return false;
            }
            var rv = {};
            for (var i in this.active_layers) {
                rv[this.active_layers[i]] = true;
            }
            return rv;
        },

        benchStart: function (id) {
            G3ME.benchmarks[id] = (new Date()).getTime();
        },

        benchStop: function (id) {
            var end = (new Date()).getTime(),
                result = end - G3ME.benchmarks[id];

            G3ME.benchmarkResults.push(result);

            var oldLength = G3ME.benchmarkResults.length;

            setTimeout(function () {
                if (oldLength === G3ME.benchmarkResults.length) {
                    G3ME.benchProcessResults();
                }
            }, 500);
        },

        benchProcessResults: function () {
            var sum = 0;

            for (var i = 0; i &lt; G3ME.benchmarkResults.length; i++) {
                sum += G3ME.benchmarkResults[i];
            }

            G3ME.benchmarkGeneralStatistics.push({
                tile: sum / G3ME.tilesOnScreen,
                request: sum / G3ME.benchmarkResults.length
            });
            G3ME.benchmarkGlobalResultPerSQL += sum / G3ME.tilesOnScreen;
            G3ME.benchmarkGlobalResultPerTile += sum / G3ME.benchmarkResults.length;
            G3ME.benchmarkResults = [];
            G3ME.benchmarks = {};
            G3ME.benchmarkElapsedBenchmarks++;

            if (G3ME.benchmarkElapsedBenchmarks &lt; G3ME.benchmarksLimit) {
                this.canvasTile.redraw();
            } else {
                G3ME.benchmarkGeneralStatistics.benchmarkGlobalResultPerSQL = G3ME.benchmarkGlobalResultPerSQL / G3ME.benchmarksLimit;
                G3ME.benchmarkGeneralStatistics.benchmarkGlobalResultPerTile = G3ME.benchmarkGlobalResultPerTile / G3ME.benchmarksLimit;
                console.log(G3ME.benchmarkGeneralStatistics);
                G3ME.benchmarkElapsedBenchmarks = 0;
            }
        },



        drawTile: function (canvas, tilePoint, performBench) {
            var ctx = canvas.getContext(&#039;2d&#039;);
            var zoom = this.map.getZoom(),
                crs = L.CRS.EPSG4326,
                nwPoint = tilePoint.multiplyBy(256),
                sePoint = nwPoint.add(new L.Point(256, 256)),
                nw = crs.project(this.map.unproject(nwPoint, zoom)),
                se = crs.project(this.map.unproject(sePoint, zoom)),
                nwmerc = this.map.latLngToLayerPoint({
                    lat: nw.y,
                    lng: nw.x
                }),
                margin = 0.00005,
                ymin = se.y - margin,
                ymax = nw.y + margin,
                xmin = nw.x - margin,
                xmax = se.x + margin,
                _2pi = 2 * Math.PI,
                _pi4 = Math.PI / 4,
                dotSize = Math.floor(0.5 + (7 / (19 - zoom))),
                parse = window.JSON.parse,
                symbology = this.site.symbology,
                imageFactor = 1,
                // imageFactor = Math.floor(30 / (22 - zoom)) / 10,
                imageFactor_2 = 0.5,
                scale = 256 * Math.pow(2, zoom),
                xscale = canvas.width / Math.abs(xmax - xmin),
                yscale = canvas.height / Math.abs(ymax - ymin),
                initialTopLeftPointX = this.map._initialTopLeftPoint.x,
                initialTopLeftPointY = this.map._initialTopLeftPoint.y,
                delta_x = initialTopLeftPointX - nwmerc.x,
                delta_y = initialTopLeftPointY - nwmerc.y,
                DEG_TO_RAD = Math.PI / 180,
                buffer = 100 / xscale,
                drawnLabels = [],
                labelCache = [],
                minDistanceToALabel = 15;


            function drawLabel(ctx, txt, size, x, y, angle, color) {

                ctx.save();

                // Anticollision primaire.
                var cur;
                ctx.fillStyle = color;
                for (var i = 0, lim = drawnLabels.length; i &lt; lim; i++) {
                    cur = drawnLabels[i];
                    if ((x &lt; (cur.x + cur.width + minDistanceToALabel)) &amp;&amp;
                        (x &gt; (cur.x - minDistanceToALabel)) &amp;&amp;
                        (y &lt; (cur.y + cur.width + minDistanceToALabel)) &amp;&amp;
                        (y &gt; (cur.y - minDistanceToALabel))) {
                        return;
                    }
                }
                var _width = ctx.measureText(txt).width;


                ctx.translate(x, y);
                var offset_x = size * imageFactor_2 + 1;
                var offset_y = 0;
                if (angle) {
                    ctx.rotate(angle * DEG_TO_RAD);
                    offset_x = -_width / 2;
                    offset_y = -4;
                }

                drawnLabels.push({
                    x: x + offset_x,
                    y: y + offset_y,
                    width: _width
                });

                ctx.font = (size / 2) + &#039;px Arial&#039;;
                ctx.strokeText(txt, offset_x, offset_y);
                ctx.fillText(txt, offset_x, offset_y);
                ctx.restore();
            }

            function drawLabels(ctx) {
                var cur;
                var lineWidth = ctx.lineWidth;
                ctx.lineWidth = 3;
                ctx.strokeStyle = &#039;white&#039;;
                for (var i = 0, lim = labelCache.length; i &lt; lim; i++) {
                    cur = labelCache[i];
                    drawLabel(ctx, cur.txt, cur.size, cur.x, cur.y, cur.angle, cur.color);
                }
                ctx.lineWidth = lineWidth;
            }

            function addLabel(txt, size, x, y, angle, color) {
                labelCache.push({
                    txt: txt,
                    x: x,
                    y: y,
                    size: size,
                    color: color,
                    angle: angle
                });
            }

            var zones = [],
                initargs = [xmin - buffer, xmax + buffer, ymin - buffer, ymax + buffer, zoom, zoom],
                finalargs = [],
                subrequests = [],
                tileExtent = {
                    ymin: ymin,
                    ymax: ymax,
                    xmin: xmin,
                    xmax: xmax
                };

            var request = &quot; SELECT * FROM ASSETS &quot;;
            request += &quot; WHERE ( xmax &gt; ? AND ? &gt; xmin AND ymax &gt; ? AND ? &gt; ymin) &quot;;
            request += &quot;    AND ( ( minzoom &lt;= 1*? OR minzoom = &#039;null&#039; ) AND ( maxzoom &gt;= 1*? OR maxzoom = &#039;null&#039; ) ) &quot;;


            if (this.active_layers) {
                request += this.active_layers.length ? &#039; and (symbolId like &quot;&#039; + this.active_layers.join(&#039;%&quot; or symbolId like &quot;&#039;) + &#039;%&quot; )&#039; : &#039; and 1=2 &#039;;
            }

            for (var i = 0; i &lt; this.site.zones.length; i++) {
                if (this.extents_match(this.site.zones[i].extent, tileExtent)) {
                    if (performBench) {
                        G3ME.benchStart(this.site.zones[i].database_name);
                    }
                    (function (zone) {
                        if (!G3ME.databases[zone.database_name]) {
                            G3ME.databases[zone.database_name] = SQLite.openDatabase({
                                name: zone.database_name,
                                bgType: 1
                            });
                        }
                        G3ME.databases[zone.database_name].transaction(function (tx) {
                            tx.executeSql(request, initargs,
                                function (tx, results) {
                                    var rows = results.rows;
                                    for (var i = 0, length = rows.length; i &lt; length; i++) {
                                        var prevX = false,
                                            prevY = false,
                                            asset = rows.item(i),
                                            geom = parse(asset.geometry),
                                            assetSymbology = symbology[asset.symbolId],
                                            coord, coord_ = {}, x, y, image;
                                        if (geom.type === &quot;MultiLineString&quot; || geom.type === &quot;Polygon&quot;) {
                                            geom.coordinates = geom.coordinates[0];
                                            ctx.strokeStyle = assetSymbology.style.strokecolor;
                                            ctx.fillStyle = assetSymbology.style.fillcolor;
                                        }
                                        if (geom.type === &quot;LineString&quot; || geom.type === &quot;MultiLineString&quot; || geom.type === &quot;Polygon&quot;) {
                                            ctx.beginPath();
                                            for (var j = 0, l = geom.coordinates.length; j &lt; l; j++) {
                                                coord = geom.coordinates[j];
                                                if (zoom &lt; 15) {
                                                    coord_.x = Math.floor(0.5 + ((coord[0] - xmin) * xscale));
                                                    coord_.y = Math.floor(0.5 + ((ymax - coord[1]) * yscale));
                                                } else {
                                                    coord_.x = coord[0] * 0.017453292519943295;
                                                    coord_.y = Math.log(Math.tan(_pi4 + (coord[1] * 0.008726646259971648)));

                                                    coord_.x = scale * (0.15915494309189535 * coord_.x + 0.5);
                                                    coord_.y = scale * (-0.15915494309189535 * coord_.y + 0.5);

                                                    coord_.x = Math.floor(0.5 + coord_.x) - initialTopLeftPointX - nwmerc.x;
                                                    coord_.y = Math.floor(0.5 + coord_.y) - initialTopLeftPointY - nwmerc.y;
                                                }

                                                if (prevX === false) {
                                                    ctx.moveTo(coord_.x, coord_.y);
                                                } else if (coord_.x === prevX &amp;&amp; coord_.y === prevY) {
                                                    continue;
                                                } else {
                                                    ctx.lineTo(coord_.x, coord_.y);
                                                }

                                                prevX = coord_.x;
                                                prevY = coord_.y;
                                            }
                                            if ((geom.type === &quot;LineString&quot; || geom.type === &quot;MultiLineString&quot;) &amp;&amp; zoom &gt; 16 &amp;&amp; asset.maplabel) {
                                                var middle = G3ME.getLineStringMiddle(geom),
                                                    _middle = {}, _segmentBegin = {};

                                                _middle.x = middle[1] * 0.017453292519943295;
                                                _middle.y = Math.log(Math.tan(_pi4 + (middle[0] * 0.008726646259971648)));

                                                _middle.x = scale * (0.15915494309189535 * _middle.x + 0.5);
                                                _middle.y = scale * (-0.15915494309189535 * _middle.y + 0.5);

                                                _middle.x = Math.floor(0.5 + _middle.x) - initialTopLeftPointX - nwmerc.x;
                                                _middle.y = Math.floor(0.5 + _middle.y) - initialTopLeftPointY - nwmerc.y;

                                                _segmentBegin.x = middle[2][0] * 0.017453292519943295;
                                                _segmentBegin.y = Math.log(Math.tan(_pi4 + (middle[2][1] * 0.008726646259971648)));

                                                _segmentBegin.x = scale * (0.15915494309189535 * _segmentBegin.x + 0.5);
                                                _segmentBegin.y = scale * (-0.15915494309189535 * _segmentBegin.y + 0.5);

                                                _segmentBegin.x = Math.floor(0.5 + _segmentBegin.x) - initialTopLeftPointX - nwmerc.x;
                                                _segmentBegin.y = Math.floor(0.5 + _segmentBegin.y) - initialTopLeftPointY - nwmerc.y;


                                                var dx = _middle.x - _segmentBegin.x,
                                                    dy = _middle.y - _segmentBegin.y;
                                                if (dy &lt; 0) {
                                                    dx = -dx;
                                                }
                                                _middle.angle = Math.acos(dx / Math.sqrt(dx * dx + dy * dy)) * (180 / Math.PI);

                                                if (_middle.angle &gt; 90) {
                                                    _middle.angle -= 180;
                                                }

                                                addLabel(asset.maplabel, assetSymbology.label.size * 2, _middle.x, _middle.y, _middle.angle, assetSymbology.label.color);
                                            }
                                            ctx.strokeStyle = assetSymbology.style.strokecolor;
                                            ctx.stroke();
                                        } else if (geom.type === &quot;Point&quot;) {

                                            coord_.x = geom.coordinates[0] * 0.017453292519943295;
                                            coord_.y = Math.log(Math.tan(_pi4 + (geom.coordinates[1] * 0.008726646259971648)));

                                            coord_.x = scale * (0.15915494309189535 * coord_.x + 0.5);
                                            coord_.y = scale * (-0.15915494309189535 * coord_.y + 0.5);

                                            coord_.x = Math.floor(0.5 + coord_.x) - initialTopLeftPointX - nwmerc.x;
                                            coord_.y = Math.floor(0.5 + coord_.y) - initialTopLeftPointY - nwmerc.y;

                                            image = symbology[asset.symbolId.toString()].style.image;

                                            if (image) {
                                                ctx.save();
                                                ctx.translate(coord_.x, coord_.y);
                                                ctx.rotate(-asset.angle * DEG_TO_RAD);
                                                ctx.drawImage(image, -image.width * imageFactor_2, -image.height * imageFactor_2,
                                                    image.width * imageFactor,
                                                    image.height * imageFactor);
                                                ctx.restore();
                                                if (zoom &gt; 16 &amp;&amp; asset.maplabel) {
                                                    addLabel(asset.maplabel, image.width, coord_.x, coord_.y, null, assetSymbology.label.color);
                                                }
                                            } else {
                                                ctx.beginPath();
                                                ctx.arc(coord_.x, coord_.y, dotSize, 0, _2pi, true);
                                                ctx.fillStyle = symbology[asset.symbolId].style.fillcolor;
                                                ctx.fill();
                                                ctx.fillText(asset.maplabel, coord_.x + 1, coord_.y + 1);
                                            }
                                        } else {
                                            Smartgeo.log(i18n.get(&quot;_G3ME_UNKNOWN_GEOMETRY&quot;, geom.type));
                                        }
                                        if (geom.type === &quot;Polygon&quot;) {
                                            ctx.fill();
                                        }
                                    }
                                    if (zoom &gt; 16) {
                                        drawLabels(ctx);
                                    }

                                    if (performBench) {
                                        G3ME.benchStop(zone.database_name);
                                    }
                                }, function (tx, SqlError) {
                                    Smartgeo.log(SqlError);
                                });
                        });
                    })(this.site.zones[i])
                }
            }
        }
    };
    return G3ME;
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
